I"à9<h2 id="basic-extraction">Basic Extraction</h2>

<ul>
  <li>OCaml   (most mature)</li>
  <li>Haskell (mostly works)</li>
  <li>Scheme  (a bit out of date)</li>
</ul>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="no">Extraction</span><span class="w"> </span><span class="s2">"imp1.ml"</span><span class="w"> </span><span class="no">ceval_step</span><span class="pi">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>When Coq processes this command:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>The file imp1.ml has been created by extraction.
The file imp1.mli has been created by extraction.
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="controlling-extraction-of-specific-types">Controlling Extraction of Specific Types</h2>

<p>å¦‚æœä¸åšä»»ä½•å¤„ç†çš„è¯â€¦ç”Ÿæˆçš„ <code class="highlighter-rouge">ml</code> é‡Œçš„ <code class="highlighter-rouge">nat</code> åˆ™éƒ½ä¼šæ˜¯ Church Numeralâ€¦</p>

<blockquote>
  <p>We can tell Coq how to extract certain <code class="highlighter-rouge">Inductive</code> definitions to specific OCaml types.
we must say:</p>
  <ol>
    <li>how the Coq type itself should be represented in OCaml</li>
    <li>how each constructor should be translated</li>
  </ol>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="no">Extract</span><span class="w"> </span><span class="k">Inductive</span><span class="w"> </span><span class="no">bool</span><span class="w"> </span><span class="p">â‡’</span><span class="w"> </span><span class="s2">"bool"</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="s2">"true"</span><span class="w"> </span><span class="s2">"false"</span><span class="w"> </span><span class="o">].</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>also, for non-enumeration types (where the constructors take arguments), 
we give an OCaml expression that can be used as a <em>â€œrecursorâ€</em> over elements of the type. (Think Church numerals.)</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="no">Extract</span><span class="w"> </span><span class="k">Inductive</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="p">â‡’</span><span class="w"> </span><span class="s2">"int"</span><span class="w">
  </span><span class="o">[</span><span class="w"> </span><span class="s2">"0"</span><span class="w"> </span><span class="s2">"(fun x â†’ x + 1)"</span><span class="w"> </span><span class="o">]</span><span class="w">
  </span><span class="s2">"(fun zero succ n â†’
      if n=0 then zero () else succ (n-1))"</span><span class="o">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="no">Extract</span><span class="w"> </span><span class="no">Constant</span><span class="w"> </span><span class="no">plus</span><span class="w"> </span><span class="p">â‡’</span><span class="w"> </span><span class="s2">"( + )"</span><span class="o">.</span><span class="w">
</span><span class="no">Extract</span><span class="w"> </span><span class="no">Constant</span><span class="w"> </span><span class="no">mult</span><span class="w"> </span><span class="p">â‡’</span><span class="w"> </span><span class="s2">"( * )"</span><span class="o">.</span><span class="w">
</span><span class="no">Extract</span><span class="w"> </span><span class="no">Constant</span><span class="w"> </span><span class="no">eqb</span><span class="w"> </span><span class="p">â‡’</span><span class="w"> </span><span class="s2">"( = )"</span><span class="o">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>æ³¨æ„ï¼šä¿è¯æå–ç»“æœçš„åˆç†æ€§æ˜¯ä½ çš„è´£ä»»ã€‚</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="no">Extract</span><span class="w"> </span><span class="no">Constant</span><span class="w"> </span><span class="no">minus</span><span class="w"> </span><span class="p">â‡’</span><span class="w"> </span><span class="s2">"( - )"</span><span class="o">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>æ¯”å¦‚è¿™ä¹ˆåšå¾ˆè¯±äººâ€¦â€¦ä½†æ˜¯æˆ‘ä»¬ Coq çš„å®šä¹‰é‡Œ <code class="highlighter-rouge">0 - 1 = 0</code>, OCaml çš„ <code class="highlighter-rouge">int</code> åˆ™ä¼šæœ‰è´Ÿæ•°â€¦</p>

<h3 id="recursor-çš„ç†è®ºä¸å®ç°---a-encoding-of-case-expression-and-sum-type">Recursor çš„ç†è®ºä¸å®ç° - a â€œencodingâ€ of case expression and sum type</h3>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="k">Fixpoint</span><span class="w"> </span><span class="no">ceval_step</span><span class="w"> </span><span class="o">(</span><span class="no">st</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">state</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">c</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">com</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">i</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">)</span><span class="w">
                    </span><span class="p">:</span><span class="w"> </span><span class="no">option</span><span class="w"> </span><span class="no">state</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">match</span><span class="w"> </span><span class="no">i</span><span class="w"> </span><span class="kp">with</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">O</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">None</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">S</span><span class="w"> </span><span class="no">i'</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
    </span><span class="kr">match</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="kp">with</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">let</span> <span class="k">rec</span> <span class="n">ceval_step</span> <span class="n">st</span> <span class="n">c</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nc">O</span> <span class="o">-&gt;</span> <span class="nc">None</span>
  <span class="o">|</span> <span class="nc">S</span> <span class="n">i'</span> <span class="o">-&gt;</span>
    <span class="p">(</span><span class="k">match</span> <span class="n">c</span> <span class="k">with</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">let</span> <span class="k">rec</span> <span class="n">ceval_step</span> <span class="n">st</span> <span class="n">c</span> <span class="n">i</span> <span class="o">=</span>
  <span class="p">(</span><span class="k">fun</span> <span class="n">zero</span> <span class="n">succ</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span> <span class="k">then</span> <span class="n">zero</span> <span class="bp">()</span> <span class="k">else</span> <span class="n">succ</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="p">(</span><span class="k">fun</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="nc">None</span><span class="p">)</span>     <span class="c">(* zero *)</span>
    <span class="p">(</span><span class="k">fun</span> <span class="n">i'</span> <span class="o">-&gt;</span>          <span class="c">(* succ *)</span>
    <span class="k">match</span> <span class="n">c</span> <span class="k">with</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>æ³¨æ„æˆ‘ä»¬æ˜¯å¦‚ä½•ä½¿ç”¨ â€œrecursorâ€ æ¥æ›¿ä»£ <code class="highlighter-rouge">case</code>, <code class="highlighter-rouge">match</code>, pattern matching å¾—ã€‚</p>

<p>recall <em>sum type</em> åœ¨ PLT ä¸­çš„è¯­æ³•ä¸è¯­ä¹‰ï¼š</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="no">T</span><span class="w"> </span><span class="p">::</span><span class="o">=</span><span class="w"> 
  </span><span class="no">T</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">T</span><span class="w">

</span><span class="no">e</span><span class="w"> </span><span class="p">::</span><span class="o">=</span><span class="w">
  </span><span class="no">case</span><span class="w"> </span><span class="no">e</span><span class="w"> </span><span class="no">of</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="no">L</span><span class="o">(</span><span class="no">e</span><span class="o">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">e</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="no">R</span><span class="o">(</span><span class="no">e</span><span class="o">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">e</span><span class="w">

</span></pre></td></tr></tbody></table></code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>                      e â†’ e' 
                  ------------- (work inside constructor)
                  C(e) -&gt; C(e')

                      e â†’ e' 
          -------------------------------   (work on the expr match against)
          case e of ... â†’  case e' of ...

     -----------------------------------------------  (match Left constructor, substitute)
     case L(v) of L(x) =&gt; e1 | R(y) =&gt; e2 â†’ e1 [v/x]

     -----------------------------------------------  (match Right constructor, substitute)
     case R(v) of L(x) =&gt; e1 | R(y) =&gt; e2 â†’ e1 [v/x]
</pre></td></tr></tbody></table></code></pre></div></div>

<p>å¯ä»¥å‘ç° <code class="highlighter-rouge">case</code> è¡¨è¾¾å¼å¯ä»¥ç†è§£ä¸ºä¸€ç§ç‰¹æ®Šçš„ applicationï¼Œä¼šå°†å…¶ argument æ ¹æ®æŸç§ tag ï¼ˆè¿™é‡Œä¸ºæ„é€ å‡½æ•°ï¼‰ apply åˆ°å¯¹åº”çš„ case body ä¸Šï¼Œ
æ¯ä¸ª case body éƒ½æ˜¯å’Œ lambda abstraction åŒæ„çš„ä¸€ç§ binderï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre> L(x) =&gt; e1     ===   Î»x.e1
 R(x) =&gt; e2     ===   Î»x.e2 

 case v e1|e2   ===   (Î»x.e1|e2) v      -- `e1` or `e2` depends on the _tag_ wrapped on `v`
</pre></td></tr></tbody></table></code></pre></div></div>

<p>è¿™ä¸ªè§’åº¦ä¹Ÿè§£é‡Šäº† Haskell/SML åœ¨ç”³æ˜å‡½æ•°æ—¶ç›´æ¥å¯¹å‚æ•°å†™ pattern match çš„ç†è®ºåˆç†æ€§.</p>

<p>æ ¹æ®ç»éªŒå‡ ä¹æ‰€æœ‰çš„ <em>binding</em> éƒ½å¯ä»¥è¢« desugar æˆå‡½æ•°ï¼ˆå³ lambda expression).
éš¾ç‚¹åœ¨äºæˆ‘ä»¬å¦‚ä½• re-implement è¿™ä¸ª <em>tag</em> çš„ <em>switch</em> æœºåˆ¶?</p>

<p>å¯¹äº <code class="highlighter-rouge">Inductive nat</code> ç¿»è¯‘åˆ° OCaml <code class="highlighter-rouge">int</code> æ—¶ï¼Œè¿™ä¸ªæœºåˆ¶å¯ä»¥ç”¨ <code class="highlighter-rouge">v =? 0</code> æ¥åˆ¤æ–­ï¼Œå› æ­¤æˆ‘ä»¬çš„ <em>recursor</em> å®ç°ä¸º</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">fun</span> <span class="n">zero</span> <span class="n">succ</span>                <span class="c">(* partial application  *)</span>
  <span class="n">n</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span>                <span class="c">(* åˆ¤æ–­ tag ... *)</span>
       <span class="k">then</span> <span class="n">zero</span> <span class="bp">()</span>          <span class="c">(* 0   case =&gt;  (Î»x.e1) v *)</span>
       <span class="k">else</span> <span class="n">succ</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>       <span class="c">(* S n case =&gt;  (Î»x.e2) v *)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

:ET